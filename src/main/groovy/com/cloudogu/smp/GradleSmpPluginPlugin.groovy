/*
 * This Groovy source file was generated by the Gradle 'init' task.
 */
package com.cloudogu.smp

import com.moowork.gradle.node.yarn.YarnTask
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.artifacts.Configuration
import org.gradle.api.artifacts.ConfigurationContainer
import org.gradle.api.artifacts.Dependency
import org.gradle.api.artifacts.PublishArtifact
import org.gradle.api.file.FileCollection
import org.gradle.api.internal.artifacts.dsl.LazyPublishArtifact
import org.gradle.api.plugins.BasePlugin
import org.gradle.api.plugins.JavaLibraryPlugin
import org.gradle.api.plugins.JavaPlugin
import org.gradle.api.plugins.JavaPluginConvention
import org.gradle.api.publish.maven.MavenPublication
import org.gradle.api.publish.maven.plugins.MavenPublishPlugin
import org.gradle.api.tasks.Copy
import org.gradle.api.tasks.SourceSet
import org.gradle.api.tasks.Sync
import org.gradle.api.tasks.bundling.War
import org.gradle.language.base.plugins.LifecycleBasePlugin
import com.hierynomus.gradle.license.tasks.LicenseCheck

class GradleSmpPluginPlugin implements Plugin<Project> {

    void apply(Project project) {
        project.plugins.apply(JavaLibraryPlugin)
        project.plugins.apply("com.github.node-gradle.node")
        project.plugins.apply("io.swagger.core.v3.swagger-gradle-plugin")
        project.plugins.apply("com.github.hierynomus.license")
        project.plugins.apply(MavenPublishPlugin)

        def extension = project.extensions.create("scmPlugin", SmpExtension)

        configureLicenseCheck(project)
        registerRepositories(project)
        registerYarnInstall(project)
        registerUIBuild(project)
        registerUITest(project)
        registerTest(project)

        def artifact = registerPackage(project, extension)
        registerRun(project, extension)
        registerPluginXml(project, extension)

        // TODO? is this ok? do we need this?
        project.afterEvaluate {
            registerOpenApiSpecGenerator(project, extension)
            configureDependencies(project, extension)
            configurePublishing(project, extension, artifact)
            configureTests(project)
        }
    }

    private static void configureLicenseCheck(Project project) {
        def licenseFile = new File(project.rootDir, "LICENSE.txt")

        project.tasks.register("licenseBuild", LicenseCheck) {
            source = project.fileTree(dir: ".").include("build.gradle", "settings.gradle")
            enabled = licenseFile.exists()
        }

        project.tasks.register("licenseUI", LicenseCheck) {
            source = project.fileTree(dir: "src/main/js")
            enabled = licenseFile.exists()
        }

        project.tasks.getByName("licenseMain").configure {
            enabled = licenseFile.exists()
        }

        project.tasks.getByName("licenseTest").configure {
            enabled = licenseFile.exists()
        }

        project.tasks.getByName("license").configure {
            dependsOn("licenseBuild", "licenseUI")
            enabled = licenseFile.exists()
        }

        project.license {
            header licenseFile
            strictCheck true

            mapping {
                tsx = 'SLASHSTAR_STYLE'
                ts = 'SLASHSTAR_STYLE'
                java = 'SLASHSTAR_STYLE'
                gradle = 'SLASHSTAR_STYLE'
            }

            exclude "**/*.mustache"
            exclude "**/*.json"
            exclude "**/*.ini"
            exclude "**/mockito-extensions/*"
            exclude "**/*.txt"
            exclude "**/*.md"
        }
    }

    private static void configureTests(Project project) {
        project.test {
            useJUnitPlatform()
        }
    }

    private static Iterable<Dependency> createDependencies(Project project, Collection<String> dependencyStrings) {
        dependencyStrings.collect { dep ->
            project.dependencies.create(dep)
        }
    }

    private static void appendDependencies(Node dependenciesNode, Iterable<Dependency> dependencies, String scope = null, boolean optional = false) {
        dependencies.forEach { dep ->
            def dependencyNode = dependenciesNode.appendNode('dependency')
            dependencyNode.appendNode('groupId', dep.group)
            dependencyNode.appendNode('artifactId', dep.name)
            if (dep.version != null && !dep.version.isEmpty()) {
                dependencyNode.appendNode('version', dep.version)
            }
            if (scope != null) {
                dependencyNode.appendNode('scope', 'provided')
            }
            if (optional) {
                dependencyNode.appendNode('optional', true)
            }
        }
    }

    private void configurePublishing(Project project, SmpExtension extension, PublishArtifact smp) {
        project.java {
            withJavadocJar()
            withSourcesJar()
        }

        project.publishing {
            publications {
                mavenJava(MavenPublication) {
                    groupId = "sonia.scm.plugins"
                    artifactId = extension.getName(project)
                    version = extension.version

                    from project.components.java
                    artifact smp

                    pom {
                        packaging = "smp"
                        description = extension.description
                    }

                    pom.withXml {
                        def rootNode = asNode()
                        rootNode.remove(rootNode.get('dependencies'))
                        def dependenciesNode = rootNode.appendNode('dependencies')

                        Set<Dependency> runtime = runtimeDependencies(project)

                        def provided = project.configurations.scmCoreDependency.allDependencies
                            .findAll { dep ->
                                return !(dep.group.equals("sonia.scm") && dep.name.equals("scm"))
                            }



                        appendDependencies(dependenciesNode, provided, 'provided')
                        appendDependencies(dependenciesNode, runtime)
                        appendDependencies(dependenciesNode, createDependencies(project, extension.dependencies))
                        appendDependencies(dependenciesNode, createDependencies(project, extension.optionalDependencies), null, true)
                    }
                }
            }
            repositories {
                maven {
                    // TODO package.scm-manager.org
                    url = "${project.buildDir}/repo"
                }
            }
        }
    }

    private static Set<Dependency> runtimeDependencies(Project project) {
        def runtime = project.configurations.implementation.allDependencies
        runtime -= project.configurations.scmCoreDependency.allDependencies
        runtime -= project.configurations.scmPluginDependency.allDependencies
        runtime
    }

    private static void registerPluginXml(Project project, extension) {
        project.tasks.getByName('classes').configure {
            dependsOn("plugin-xml")
        }
        project.tasks.register("plugin-xml", PluginXmlTask) {
            it.extension = extension
            it.moduleXml = new File(project.buildDir, "classes/java/main/META-INF/scm/module.xml")
            it.pluginXml = new File(project.buildDir, "smp/META-INF/scm/plugin.xml")

            it.mustRunAfter("compileJava")
        }

        project.tasks.getByName("jar").configure {
            exclude("**/module.xml")
            from "build/smp"
        }
    }

    private static void registerRepositories(Project project) {
        project.repositories {
            maven {
                url "https://packages.scm-manager.org/repository/public/"
            }
        }
    }

    private static void configureDependencies(Project project, SmpExtension extension) {
        // gradle has xerces on it classpath, which breaks our annotation processor
        // so we force jdk build in for now
        // @see https://stackoverflow.com/questions/53299280/java-and-xerces-cant-find-property-xmlconstants-access-external-dtd
        System.setProperty("javax.xml.parsers.DocumentBuilderFactory",
                "com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl");

        // We define our own configuration container that we are able to use all dependencies for compilation,
        // but remove the core dependencies before packaging
        // https://github.com/gradle/gradle/blob/master/subprojects/plugins/src/main/java/org/gradle/api/plugins/WarPlugin.java#L72
        ConfigurationContainer configurationContainer = project.getConfigurations()
        Configuration coreDependency = configurationContainer
                .create("scmCoreDependency")
                .setVisible(false)
                .setDescription("Additional classpath for libraries which are provided from scm code.")

        Configuration pluginDependency = configurationContainer
                .create("scmPluginDependency")
                .setVisible(false)
                .setDescription("Plugin dependencies.")
                .extendsFrom(coreDependency)

        configurationContainer.getByName(JavaPlugin.COMPILE_CONFIGURATION_NAME).extendsFrom(pluginDependency)

        project.dependencies {
            // we enforce the dependency versions from scm-manager root pom dependency management
            // TODO at all dependencies from here to dependencyManagement of core
            // for older version we could add those manually based on the scm version
            scmCoreDependency enforcedPlatform("sonia.scm:scm:${extension.scmVersion}")

            scmCoreDependency "sonia.scm:scm-core:${extension.scmVersion}"

            // is provided in scm-core
            scmCoreDependency "javax.ws.rs:javax.ws.rs-api"
            scmCoreDependency "io.swagger.core.v3:swagger-annotations"
            // TODO define in dependencyManagement
            scmCoreDependency 'javax.servlet:javax.servlet-api:3.1.0'

            scmCoreDependency 'org.projectlombok:lombok'
            scmCoreDependency 'org.mapstruct:mapstruct-jdk8'

            // register annotation processors
            // TODO because it is defined as provided in dependencyManagement?
            annotationProcessor 'org.mapstruct:mapstruct-processor:1.3.1.Final'
            // TODO because it is defined as provided in dependencyManagement?
            annotationProcessor 'org.projectlombok:lombok:1.18.12'
            annotationProcessor "sonia.scm:scm-annotation-processor:${extension.scmVersion}"

            // test dependencies
            testImplementation "sonia.scm:scm-test:${extension.scmVersion}"

            // resteasy test dependencies
            testImplementation "org.jboss.resteasy:resteasy-core"
            testImplementation "org.jboss.resteasy:resteasy-core-spi"
            testImplementation "org.jboss.resteasy:resteasy-jackson2-provider"

            // test engine
            // TODO because it is defined as provided in dependencyManagement?
            testAnnotationProcessor 'org.projectlombok:lombok:1.18.12'

            testImplementation 'org.junit.jupiter:junit-jupiter-api'
            testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'

            testImplementation 'org.assertj:assertj-core'
            testImplementation 'org.mockito:mockito-core'
            testImplementation 'org.mockito:mockito-junit-jupiter'

            // we have to add both smp and jar,
            // because the smp (default artifact) knows the dependencies and the jar knows the plugin classes
            extension.dependencies.forEach { dep ->
                scmPluginDependency "${dep}"
                scmPluginDependency "${dep}@jar"
            }

            extension.optionalDependencies.forEach { dep ->
                scmPluginDependency "${dep}"
                scmPluginDependency "${dep}@jar"
            }
        }
    }

    private static Set<File> resolveSmp(Project project, String dependencyString) {
        String coordinates = dependencyString
        if (!dependencyString.endsWith("@smp")) {
            coordinates = dependencyString + "@smp"
        }
        def dependency = project.dependencies.create(coordinates)
        def configuration = project.configurations.detachedConfiguration(dependency)
        configuration.resolve()
        configuration.files
    }

    private static void registerRun(Project project, SmpExtension extension) {
        project.tasks.register("copy-dependencies", Copy) {
            extension.dependencies.each { dependencyString ->
                def files = resolveSmp(project, dependencyString)
                from(files)
            }

            extension.optionalDependencies.each { dependencyString ->
                def files = resolveSmp(project, dependencyString)
                from(files)
            }

            destinationDir = new File(extension.getScmHome(project), "plugins")
        }

        project.tasks.register("prepare-home", Sync) {
            createPackagingClasspath(project).each { file ->
                if (file.name.endsWith(".jar")) {
                    from(file) {
                        into("lib")
                    }
                } else if (file.name == "main") {
                    from(file) {
                        into("classes")
                        exclude("**/module.xml")
                    }
                } else {
                    println "WARNING: unknown classpath entry ${file}"
                }
            }

            from "build/smp"
            from("build/resources/main/META-INF") {
                into "META-INF"
            }
            from("src/main/webapp") {
                into "webapp"
            }

            destinationDir = new File(extension.getScmHome(project), "plugins/${extension.getName(project)}")
            dependsOn("classes", "copy-dependencies")
        }

        project.tasks.register("run", RunTask) {
            description = "Run SCM-Manager with the plugin installed"
            it.extension = extension
            dependsOn("prepare-home", "yarn_install")
        }
    }

    private static Iterable<File> createPackagingClasspath(Project project) {
        FileCollection runtimeClasspath = project.getConvention().getPlugin(JavaPluginConvention.class)
                .getSourceSets().getByName(SourceSet.MAIN_SOURCE_SET_NAME).getRuntimeClasspath()
        Configuration scmPluginDependency = project.getConfigurations().getByName("scmPluginDependency")
        runtimeClasspath - scmPluginDependency
    }

    private static void registerOpenApiSpecGenerator(Project project, SmpExtension extension) {
        project.tasks.getByName("resolve") {
            outputFileName = 'openapi'
            outputFormat = 'JSONANDYAML'
            prettyPrint = 'TRUE'
            classpath = project.sourceSets.main.runtimeClasspath
            resourcePackages = extension.openApiSpec.packages
            outputDir = new File(project.buildDir, "smp/META-INF/scm")
            skip = extension.openApiSpec.packages.isEmpty()

            mustRunAfter("classes")
        }
    }

    private PublishArtifact registerPackage(Project project, SmpExtension extension) {
        String name = extension.getName(project)

        def smp = project.tasks.register("smp", War) {
            description = 'Generates the SMP package'
            group = BasePlugin.BUILD_GROUP
            archiveFileName.set("${name}.smp")
            archiveExtension.set("smp")

            createPackagingClasspath(project).each { file ->
                if (file.name.endsWith(".jar")) {
                    from(file) {
                        into("lib")
                    }
                } else if (file.name == "main") {
                    from(file) {
                        into("classes")
                        exclude("**/module.xml")
                    }
                } else {
                    println "WARNING: unknown classpath entry ${file}"
                }
            }

            from("build/resources/main/META-INF") {
                into "META-INF"
            }

            from("build/webapp") {
                into "webapp"
            }
            from("build/smp")
            from("src/main/webapp") {
                into "webapp"
            }

            dependsOn("classes", "ui-bundle", "resolve")
        }

        project.tasks.getByName("assemble").configure {
            dependsOn("release-yaml")
        }

        project.tasks.register("release-yaml", ReleaseYamlTask) {
            it.extension = extension
            it.releaseYaml = new File(project.buildDir, "libs/release.yaml")
            it.smp = new File(project.buildDir, "libs/${name}.smp")

            dependsOn("smp")
        }

        new LazyPublishArtifact(smp)
    }

    private static void registerTest(Project project) {
        project.tasks.getByName('test').configure {
            dependsOn("ui-tests")
        }
    }

    private static void registerUITest(Project project) {
        project.tasks.register("ui-tests", YarnTask) {
            inputs.file("package.json")
            inputs.file("yarn.lock")
            inputs.dir("src/main/js")

            outputs.dir("target/jest-reports")

            args = ['run', 'test']
            dependsOn("yarn_install")

            group = LifecycleBasePlugin.VERIFICATION_GROUP
            description = "Run ui tests"
        }
    }

    private static void registerUIBuild(Project project) {
        project.tasks.register("ui-bundle", YarnTask) {
            inputs.file("package.json")
            inputs.file("yarn.lock")
            inputs.dir("src/main/js")

            outputs.dir("build/webapp/assets")

            args = ['run', 'build']
            dependsOn("yarn_install")

            group = BasePlugin.BUILD_GROUP
            description = "Assembles the plugin ui bundle"
        }
    }

    private static void registerYarnInstall(Project project) {
        project.tasks.getByName('yarn_install').configure {
            inputs.file("package.json")
            inputs.file("yarn.lock")
            outputs.dir("node_modules")

            description = "Install ui dependencies"
        }
    }
}
