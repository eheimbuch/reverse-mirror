/*
 * This Groovy source file was generated by the Gradle 'init' task.
 */
package com.cloudogu.smp

import com.moowork.gradle.node.yarn.YarnTask
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.artifacts.Configuration
import org.gradle.api.artifacts.ConfigurationContainer
import org.gradle.api.artifacts.PublishArtifact
import org.gradle.api.file.FileCollection
import org.gradle.api.internal.artifacts.dsl.LazyPublishArtifact
import org.gradle.api.plugins.BasePlugin
import org.gradle.api.plugins.JavaLibraryPlugin
import org.gradle.api.plugins.JavaPlugin
import org.gradle.api.plugins.JavaPluginConvention
import org.gradle.api.publish.maven.MavenPublication
import org.gradle.api.publish.maven.plugins.MavenPublishPlugin
import org.gradle.api.tasks.Copy
import org.gradle.api.tasks.SourceSet
import org.gradle.api.tasks.Sync
import org.gradle.api.tasks.bundling.War
import org.gradle.language.base.plugins.LifecycleBasePlugin

class GradleSmpPluginPlugin implements Plugin<Project> {

    void apply(Project project) {
        project.plugins.apply(JavaLibraryPlugin)
        project.plugins.apply("com.github.node-gradle.node")
        project.plugins.apply(MavenPublishPlugin)

        def extension = project.extensions.create("scmPlugin", SmpExtension)

        registerRepositories(project)
        registerYarnInstall(project)
        registerUIBuild(project)
        registerUITest(project)
        registerTest(project)
        def artifact = registerPackage(project)
        registerRun(project, extension)
        registerInfo(project, extension)
        registerPluginXml(project, extension)

        // TODO? is this ok? do we need this?
        project.afterEvaluate {
            configureDependencies(project, extension)
            configurePublishing(project, extension, artifact)
            configureTests(project)
        }
    }

    private static void configureTests(Project project) {
        project.test {
            useJUnitPlatform()
        }
    }

    private static void configurePublishing(Project project, SmpExtension extension, PublishArtifact smp) {
        project.java {
            withJavadocJar()
            withSourcesJar()
        }

        project.publishing {
            publications {
                mavenJava(MavenPublication) {
                    groupId = "sonia.scm.plugins"
                    artifactId = extension.getName(project)
                    version = extension.version
                    from project.components.java
                    artifact smp
                }
            }
            repositories {
                maven {
                    // TODO package.scm-manager.org
                    url = "${project.buildDir}/repo"
                }
            }
        }
    }

    private static void registerPluginXml(Project project, extension) {
        project.tasks.getByName('classes').configure {
            dependsOn("plugin-xml")
        }
        project.tasks.register("plugin-xml", PluginXmlTask) {
            it.extension = extension
            it.moduleXml = new File(project.buildDir, "classes/java/main/META-INF/scm/module.xml")
            it.pluginXml = new File(project.buildDir, "smp/META-INF/scm/plugin.xml")

            it.mustRunAfter("compileJava")
        }
    }

    private static void registerRepositories(Project project) {
        project.repositories {
            maven {
                url "https://packages.scm-manager.org/repository/public/"
            }
        }
    }

    private static void configureDependencies(Project project, SmpExtension extension) {
        // gradle has xerces on it classpath, which breaks our annotation processor
        // so we force jdk build in for now
        // @see https://stackoverflow.com/questions/53299280/java-and-xerces-cant-find-property-xmlconstants-access-external-dtd
        System.setProperty("javax.xml.parsers.DocumentBuilderFactory",
                "com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl");

        // We define our own configuration container that we are able to use all dependencies for compilation,
        // but remove the core dependencies before packaging
        // https://github.com/gradle/gradle/blob/master/subprojects/plugins/src/main/java/org/gradle/api/plugins/WarPlugin.java#L72
        ConfigurationContainer configurationContainer = project.getConfigurations()
        Configuration coreDependency = configurationContainer
                .create("scmCoreDependency")
                .setVisible(false)
                .setDescription("Additional classpath for libraries which are provided from scm code.")

        configurationContainer.getByName(JavaPlugin.COMPILE_CONFIGURATION_NAME).extendsFrom(coreDependency);
        configurationContainer.getByName(JavaPlugin.RUNTIME_CONFIGURATION_NAME).extendsFrom(coreDependency);

        project.dependencies {
            // we enforce the dependency versions from scm-manager root pom dependency management
            // TODO at all dependencies from here to dependencyManagement of core
            // for older version we could add those manually based on the scm version
            scmCoreDependency enforcedPlatform("sonia.scm:scm:${extension.scmVersion}")

            scmCoreDependency "sonia.scm:scm-core:${extension.scmVersion}"

            // is provided in scm-core
            scmCoreDependency "javax.ws.rs:javax.ws.rs-api"
            scmCoreDependency "io.swagger.core.v3:swagger-annotations"
            // TODO define in dependencyManagement
            scmCoreDependency 'javax.servlet:javax.servlet-api:3.1.0'

            scmCoreDependency 'org.projectlombok:lombok'
            scmCoreDependency 'org.mapstruct:mapstruct-jdk8'

            // register annotation processors
            // TODO because it is defined as provided in dependencyManagement?
            annotationProcessor 'org.mapstruct:mapstruct-processor:1.3.1.Final'
            // TODO because it is defined as provided in dependencyManagement?
            annotationProcessor 'org.projectlombok:lombok:1.18.12'
            annotationProcessor "sonia.scm:scm-annotation-processor:${extension.scmVersion}"

            // test dependencies
            testImplementation "sonia.scm:scm-test:${extension.scmVersion}"

            // resteasy test dependencies
            testImplementation "org.jboss.resteasy:resteasy-core"
            testImplementation "org.jboss.resteasy:resteasy-core-spi"
            testImplementation "org.jboss.resteasy:resteasy-jackson2-provider"

            // test engine
            // TODO because it is defined as provided in dependencyManagement?
            testAnnotationProcessor 'org.projectlombok:lombok:1.18.12'

            testImplementation 'org.junit.jupiter:junit-jupiter-api'
            testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'

            testImplementation 'org.assertj:assertj-core'
            testImplementation 'org.mockito:mockito-core'
            testImplementation 'org.mockito:mockito-junit-jupiter'

            // we have to add both smp and jar,
            // because the smp (default artifact) knows the dependencies and the jar knows the plugin classes
            extension.dependencies.forEach { dep ->
                scmCoreDependency "${dep}"
                scmCoreDependency "${dep}@jar"
            }

            extension.optionalDependencies.forEach { dep ->
                scmCoreDependency "${dep}"
                scmCoreDependency "${dep}@jar"
            }
        }
    }

    private static Set<File> resolveSmp(Project project, String dependencyString) {
        String coordinates = dependencyString
        if (!dependencyString.endsWith("@smp")) {
            coordinates = dependencyString + "@smp"
        }
        def dependency = project.dependencies.create(coordinates)
        def configuration = project.configurations.detachedConfiguration(dependency)
        configuration.resolve()
        configuration.files
    }

    private static void registerRun(Project project, SmpExtension extension) {
        project.tasks.register("copy-dependencies", Copy) {
            extension.dependencies.each { dependencyString ->
                def files = resolveSmp(project, dependencyString)
                from(files)
            }

            extension.optionalDependencies.each { dependencyString ->
                def files = resolveSmp(project, dependencyString)
                from(files)
            }

            destinationDir = new File(extension.getScmHome(project), "plugins")
        }

        project.tasks.register("prepare-home", Sync) {
            createPackagingClasspath(project).each { file ->
                if (file.name.endsWith(".jar")) {
                    from(file) {
                        into("lib")
                    }
                } else if (file.name == "main") {
                    from(file) {
                        into("classes")
                        exclude("**/module.xml")
                    }
                } else {
                    println "WARNING: unknown classpath entry ${file}"
                }
            }

            from "build/smp"
            from("build/resources/main/META-INF") {
                into "META-INF"
            }
            from("src/main/webapp") {
                into "webapp"
            }

            destinationDir = new File(extension.getScmHome(project), "plugins/${extension.getName(project)}")
            dependsOn("classes", "copy-dependencies")
        }

        project.tasks.register("run", RunTask) {
            description = "Run SCM-Manager with the plugin installed"
            it.extension = extension
            dependsOn("prepare-home", "yarn_install")
        }
    }

    private static FileCollection createPackagingClasspath(Project project) {
        FileCollection runtimeClasspath = project.getConvention().getPlugin(JavaPluginConvention.class)
                .getSourceSets().getByName(SourceSet.MAIN_SOURCE_SET_NAME).getRuntimeClasspath()
        Configuration scmCoreDependency = project.getConfigurations().getByName("scmCoreDependency")
        runtimeClasspath - scmCoreDependency
    }

    private PublishArtifact registerPackage(Project project) {
        def smp = project.tasks.register("smp", War) {
            description = 'Generates the SMP package'
            group = BasePlugin.BUILD_GROUP
            archiveFileName.set("${project.name}.smp")
            archiveExtension.set("smp")

            createPackagingClasspath(project).each { file ->
                if (file.name.endsWith(".jar")) {
                    from(file) {
                        into("lib")
                    }
                } else if (file.name == "main") {
                    from(file) {
                        into("classes")
                        exclude("**/module.xml")
                    }
                } else {
                    println "WARNING: unknown classpath entry ${file}"
                }
            }

            from("build/resources/main/META-INF") {
                into "META-INF"
            }

            from("build/webapp") {
                into "webapp"
            }
            from("build/smp")
            from("src/main/webapp") {
                into "webapp"
            }

            dependsOn("classes", "ui-bundle")
        }

        project.tasks.getByName("assemble").configure {
            dependsOn("smp")
        }

        new LazyPublishArtifact(smp)
    }

    private static void registerTest(Project project) {
        project.tasks.getByName('test').configure {
            dependsOn("ui-tests")
        }
    }

    private static void registerUITest(Project project) {
        project.tasks.register("ui-tests", YarnTask) {
            inputs.file("package.json")
            inputs.file("yarn.lock")
            inputs.dir("src/main/js")

            outputs.dir("target/jest-reports")

            args = ['run', 'test']
            dependsOn("yarn_install")

            group = LifecycleBasePlugin.VERIFICATION_GROUP
            description = "Run ui tests"
        }
    }

    private static void registerUIBuild(Project project) {
        project.tasks.register("ui-bundle", YarnTask) {
            inputs.file("package.json")
            inputs.file("yarn.lock")
            inputs.dir("src/main/js")

            outputs.dir("build/webapp/assets")

            args = ['run', 'build']
            dependsOn("yarn_install")

            group = BasePlugin.BUILD_GROUP
            description = "Assembles the plugin ui bundle"
        }
    }

    private static void registerYarnInstall(Project project) {
        project.tasks.getByName('yarn_install').configure {
            inputs.file("package.json")
            inputs.file("yarn.lock")
            outputs.dir("node_modules")

            description = "Install ui dependencies"
        }
    }

    private static void registerInfo(Project project, SmpExtension extension) {
        project.tasks.register("scm-info") {
            println "scmVersion: ${extension.scmVersion}"
            println "dependencies: ${extension.dependencies}"
            println "optionalDependencies: ${extension.optionalDependencies}"
        }
    }
}
